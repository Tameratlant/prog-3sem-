//Запускать с - pthread - lm
//Для упрощения дебага почти все, что можно, вынесено в отдельные функции
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>
#include <math.h>
#define THREADS_NUMBER 10
#define DATA_SIZE 1000

double* data = NULL;
double sum_of_segment[THREADS_NUMBER];
double sum_square_of_segment[THREADS_NUMBER];

typedef struct {
	int start;
	int end;
	int id;
} Segment;
Segment segments[THREADS_NUMBER];
int seze_of_segment = DATA_SIZE / THREADS_NUMBER;

pthread_t thread_id[THREADS_NUMBER];


void make_data() {														//Заполняем массив мусором, который будем анализировать
	//printf("1");
	for (int i = 0; i < DATA_SIZE; i++) {
		data[i] = rand();
	}
}

void* Sum(void* dummy) {												//Находим сумму и сумму квадратов конкретного куска
	//printf("2");
	Segment segment = *((Segment*)dummy);
	sum_of_segment[segment.id] = 0;
	sum_square_of_segment[segment.id] = 0;
	for (int i = segment.start; i < segment.end; i++) {
		sum_of_segment[segment.id] += data[i];
		sum_square_of_segment[segment.id] += pow(data[i], 2);
	}
}

void fill_segments() {													//Распределяем куски данных по сегментам
	//printf("3");
	for (int i = 0; i < THREADS_NUMBER; i++) {
		segments[i].id = i;
		segments[i].start = seze_of_segment * i;
		segments[i].end = segments[i].start + seze_of_segment;
	}
}

void thread_create() {
	int result = 0;
	
	for (int i = 0; i < THREADS_NUMBER; i++) {							//Создаем нити и отдаем каждой по сегменту
		if ((result = (pthread_create(&(thread_id[i]), 
					  (pthread_attr_t*)NULL, 
				      Sum, 
					  &(segments[i])))) != 0) {
			printf("Error on thread create, return value = %d\n", result);
			exit(-1);
		}
	}
	for (int i = 0; i < THREADS_NUMBER; i++) {							//Ждем завершения исполнения
		pthread_join(thread_id[i], NULL);
	}
}
void results_out(double a, double b, double c) {						//Просто выводит все посчитанное
	printf("The sum of all experimental data = %lf\n", a);
	printf("Math expectation = %lf\n", b);
	printf("Dispersion = %lf\n", c);
}


int main() {
	int i = 0;
	data = (double*)calloc(DATA_SIZE, sizeof(double));
	make_data();
	fill_segments();
	thread_create();
	double sum = 0, 
		sum_square = 0, 
		math_expectation = 0, 
		math_expectation_of_square = 0;

	for (i = 0; i < THREADS_NUMBER; i++) {								//Объединение того, что посчитали нити
		sum += sum_of_segment[i];
		sum_square += sum_square_of_segment[i];
	}

	math_expectation = sum / DATA_SIZE;
	math_expectation_of_square = sum_square / DATA_SIZE;
	results_out(sum, math_expectation, math_expectation_of_square - pow(math_expectation, 2));
	free(data);
	return 0;
}
// TODO: нужно измерить ускорение
